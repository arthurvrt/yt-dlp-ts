import {runYtDlp} from "./basic";
import {promptUserForFilePath} from "./cli-utils";
import prompts from "prompts";
import {downloadVideo} from "./downloadVideo";
import {AvailableFormats, getCommonFormats} from "./format";

const playlistUrl = process.argv[2];

if (!playlistUrl) {
  console.error("‚ùå Veuillez fournir une URL de playlist YouTube.");
  process.exit(1);
}

/**
 * R√©cup√®re les vid√©os d'une playlist.
 */
const getPlaylistVideos = async (playlistUrl: string): Promise<string[]> => {
  const playlistInfo = await runYtDlp(["--flat-playlist", playlistUrl]);
  if (!playlistInfo || !playlistInfo.entries) return [];

  console.log(`üìÇ ${playlistInfo.entries.length} vid√©os trouv√©es.`);

  return playlistInfo.entries.map((entry: any) => entry.url);
};

/**
 * Permet √† l'utilisateur de choisir la r√©solution et le format.
 */
const promptUserForFormat = async (availableFormats: AvailableFormats) => {
  const {resolution} = await prompts({
    type: "select",
    name: "resolution",
    message: "\nüì∫ Choisissez la r√©solution souhait√©e :",
    choices: Object.keys(availableFormats)
      .map(Number)
      .filter((res) => availableFormats[res].size > 0)
      .sort((a, b) => b - a)
      .map((res) => ({title: `${res}p`, value: res})),
  });

  const {format} = await prompts({
    type: "select",
    name: "format",
    message: "üéûÔ∏è Choisissez le format vid√©o :",
    choices: Array.from(availableFormats[resolution]).map((ext) => ({
      title: ext.toUpperCase(),
      value: ext,
    })),
  });

  return {resolution, format};
};

/**
 * T√©l√©charge toutes les vid√©os d'une playlist en parall√®le.
 */
const downloadPlaylist = async (
  videoUrls: string[],
  resolution: number,
  format: string,
  filePath: string
) => {
  console.log(`\nüöÄ T√©l√©chargement des ${videoUrls.length} vid√©os en cours...`);

  // Lancer les t√©l√©chargements en parall√®le
  const downloadPromises = videoUrls.map((videoUrl) =>
    downloadVideo({videoUrl, format, filePath, resolution})
  );

  // Attendre que tous les t√©l√©chargements soient termin√©s
  await Promise.all(downloadPromises);
  console.log("\n‚úÖ Tous les t√©l√©chargements sont termin√©s !");
};

/**
 * Ex√©cute le processus de t√©l√©chargement de playlist.
 */
export const downloadYouTubePlaylistInParalelle = async (
  playlistUrl: string
) => {
  const filePath = await promptUserForFilePath();
  // R√©cup√©rer les URLs des vid√©os de la playlist
  const videoUrls = await getPlaylistVideos(playlistUrl);
  if (videoUrls.length === 0) {
    console.log("‚ùå Aucune vid√©o trouv√©e dans la playlist.");
    return;
  }
  const availableFormats = await getCommonFormats(videoUrls);
  if (!availableFormats) return;

  const {resolution, format} = await promptUserForFormat(availableFormats);
  await downloadPlaylist(videoUrls, resolution, format, filePath);
};
